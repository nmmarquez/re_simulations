ggplot(df, aes(x, yhat)) + geom_line() +
geom_ribbon(aes(ymin=lower, ymax=upper), fill = "grey70")
ggplot(df, aes(x, yhat)) + geom_line(aes(size=2)) +
geom_ribbon(aes(ymin=lower, ymax=upper), fill = "grey70")
ggplot(df, aes(x, yhat)) +
geom_ribbon(aes(ymin=lower, ymax=upper), fill = "grey70") +
+ geom_line(aes(size=2))
ggplot(df, aes(x, yhat)) +
geom_ribbon(aes(ymin=lower, ymax=upper), fill = "grey70") +
geom_line(aes(size=2))
ggplot(df, aes(x, yhat)) +
geom_ribbon(aes(ymin=lower, ymax=upper), fill = "grey70") +
geom_line(aes(size=1))
ggplot(df, aes(x, yhat)) +
geom_ribbon(aes(ymin=lower, ymax=upper), fill = "grey70") +
geom_line()
coef(model)
library(mvtnorm)
rmvnorm(draw_num, mean=coef(model), sigma=vcov(model))
cbind(rep(1, N), X)
draws <- cbind(rep(1, N), X) %*% beta_draws
beta_draws <- rmvnorm(draw_num, mean=coef(model), sigma=vcov(model))
draws <- cbind(rep(1, N), X) %*% beta_draws
draws <- cbind(rep(1, N), X) %*% t(beta_draws)
test <- rnbinom(N * draw_num, mu=draws, size=theta)
draws <- exp(cbind(rep(1, N), X) %*% t(beta_draws))
test <- rnbinom(N * draw_num, mu=draws, size=theta)
dim(test)
length(test)
dim(draws)
dim(draws)[1] * dim(draws)[2] == length(test)
diag(4)
mat <- diag(4)
mat[1,2] <-2
mat
c(mat)
draws_with_error <- matrix(rnbinom(N * draw_num, mu=c(draws), size=theta),
nrow=N, ncol=draw_num)
lwr_bound <- apply(draws_with_error, 1, quantile, probs=.025)
upr_bound <- apply(draws_with_error, 1, quantile, probs=.975)
df <- data.frame(y=Y, x=X, yhat=yhat, lower=lwr_bound, upper=upr_bound)
ggplot(df, aes(x, yhat)) + geom_line()
ggplot(df, aes(x, yhat)) +
geom_ribbon(aes(ymin=lower, ymax=upper), fill = "grey70") +
geom_line()
rm(list=ls())
library(stats)
library(MASS)
library(ggplot2)
library(package)
N <- 100000 # number of obs
X <- rnorm(N) # covriate
B0 <- .4 # true beta intercept
B1 <- .1 # true beta slope on covariate
theta <- .1 # overdispersion parameter
Y <- rnbinom(N, mu=exp(B0 + B1 * X), size=theta) # simulate observations
model <- glm.nb(Y ~ X) # fit the model
summary(model) # check out the fit diagnostics
draw_num <- 1000 # number of draws I want for each observation
beta_draws <- rmvnorm(draw_num, mean=coef(model), sigma=vcov(model))
draws <- exp(cbind(rep(1, N), X) %*% t(beta_draws))
draws_with_error <- sapply(1:N, function(x) sapply(1:draw_num, function(y)
rnbinom(1, draws())))
draws_with_error <- matrix(rnbinom(N * draw_num, mu=c(draws), size=theta),
nrow=N, ncol=draw_num)
yhat <- model$fitted.values # extract the fitted values
lwr_bound <- apply(draws_with_error, 1, quantile, probs=.025)
upr_bound <- apply(draws_with_error, 1, quantile, probs=.975)
df <- data.frame(y=Y, x=X, yhat=yhat, lower=lwr_bound, upper=upr_bound)
ggplot(df, aes(x, yhat)) + geom_line()
ggplot(df, aes(x, yhat)) +
geom_ribbon(aes(ymin=lower, ymax=upper), fill = "grey70") +
geom_line()
rm(list=ls())
library(stats)
library(MASS)
library(ggplot2)
N <- 100000 # number of obs
X <- rnorm(N) # covriate
B0 <- .4 # true beta intercept
B1 <- .1 # true beta slope on covariate
theta <- .1 # overdispersion parameter
Y <- rnbinom(N, mu=exp(B0 + B1 * X), size=theta) # simulate observations
model <- glm.nb(Y ~ X) # fit the model
summary(model) # check out the fit diagnostics
draw_num <- 1000 # number of draws I want for each observation
beta_draws <- rmvnorm(draw_num, mean=coef(model), sigma=vcov(model))
draws <- exp(cbind(rep(1, N), X) %*% t(beta_draws))
draws_with_error <- matrix(rnbinom(N * draw_num, mu=c(draws_with_error),
size=theta), nrow=N, ncol=draw_num)
draws_with_error <- matrix(rnbinom(N * draw_num, mu=c(draws),
size=theta), nrow=N, ncol=draw_num)
yhat <- model$fitted.values # extract the fitted values
lwr_bound <- apply(draws_with_error, 1, quantile, probs=.025)
upr_bound <- apply(draws_with_error, 1, quantile, probs=.975)
df <- data.frame(y=Y, x=X, yhat=yhat, lower=lwr_bound, upper=upr_bound)
ggplot(df, aes(x, yhat)) + geom_line()
ggplot(df, aes(x, yhat)) +
geom_ribbon(aes(ymin=lower, ymax=upper), fill = "grey70") +
geom_line()
source('~/Documents/code_exchange_fall_2016/nmarquez/nblm.R', echo=TRUE)
?cut_interval
?cut
cut(rnorm(100), c(-.2, 0, 1, 3))
cut(rnorm(100), c(-Inf, -.2, 0, 1, 3, Inf))
cut(rnorm(100), c(-Inf, -.2, 0, 1, 3, Inf), labels=c(1,2,3,4,))
cut(rnorm(100), c(-Inf, -.2, 0, 1, 3, Inf), labels=c(1,2,3,4,5))
cut(rnorm(100), c(-Inf, -.2, 0, 1, Inf), labels=c(1,2,3,4))
library(data.table)
df <- as.data.table(sleep)
df
df[,1]
df[,1,with=F]
df[,1,with=F]
as.vector(df[,1,with=F])
(df[,1,with=F][1]
}}
df[,1,with=F][1]
df[,1,with=F][[1]]
df[,1,with=F]
df[,1,with=F]
df[,1,with=F][[1]]
df[[,1,with=F]]
df
df[[2]]
df[[3]]
df[[1]]
df
rm(list=ls())
sleep
?sleep
?geyser
?iris
rm(list=ls())
library(stats)
library(MASS)
library(ggplot2)
library(data.table)
N <- 100000 # number of obs
X <- rnorm(N) # covriate
B0 <- .4 # true beta intercept
B1 <- .1 # true beta slope on covariate
theta <- .1 # overdispersion parameter
Y <- rnbinom(N, mu=exp(B0 + B1 * X), size=theta) # simulate observations
model <- glm.nb(Y ~ X) # fit the model
summary(model) # check out the fit diagnostics
draw_num <- 1000 # number of draws I want for each observation
beta_draws <- rmvnorm(draw_num, mean=coef(model), sigma=vcov(model))
draws <- exp(cbind(rep(1, N), X) %*% t(beta_draws))
model$theta
model$theta, model$SE.theta
rnorm(N * draw_num, model$theta, model$SE.theta)
theta_draws <- rnorm(N * draw_num, model$theta, model$SE.theta)
draws_with_error <- matrix(rnbinom(N * draw_num, mu=c(draws), size=theta_draws),
nrow=N, ncol=draw_num)
yhat <- model$fitted.values # extract the fitted values
lwr_bound <- apply(draws_with_error, 1, quantile, probs=.025)
upr_bound <- apply(draws_with_error, 1, quantile, probs=.975)
df <- data.frame(y=Y, x=X, yhat=yhat, lower=lwr_bound, upper=upr_bound)
ggplot(df, aes(x, yhat)) + geom_line()
ggplot(df, aes(x, yhat)) +
geom_ribbon(aes(ymin=lower, ymax=upper), fill = "grey70") +
geom_line()
source('~/Documents/fbd/GKModel/ar1.R', echo=TRUE)
sigma <- .3
N <- 1000
t1 <- rnorm(N, 0, sigma)
t2 <- rnorm(N, t1, sigma)
rm(list=ls())
years_forecasted <- 2040 - 2014
ar1_draws <- matrix(0, nrow=years_forecasted, ncol=N)
rm(list=ls())
sigma <- .3
N <- 1000
years_forecasted <- 2040 - 2014
ar1_draws <- matrix(0, nrow=years_forecasted, ncol=N)
rm(list=ls())
sigma <- .3
N <- 1000
years_forecasted <- 2040 - 2014
ar1_draws <- matrix(0, nrow=years_forecasted, ncol=N)
for (i in 2:years_forecasted){
ar1_draws[i,] <- rnorm(N, ar1_draws[i-1,], sigma)
}
apply(ar1_draws, 1, sd)
apply(ar1_draws, 1, mean)
qbinom(.025, size=N, p=.1)
qbinom(.025, size=400, p=.1)
qbinom(.025, size=400, p=.1)
qbinom(c(.025, .975), size=400, p=.1)
qbinom(c(.025, .975), size=400, p=.1, lower.tail = F)
qbinom(c(.025, .975), size=400, prob=.1, lower.tail = F)
qbinom(.025, size=400, prob=.1, lower.tail = F)
qbinom(.025, size=400, prob=.1, lower.tail = T)
qbinom(.025, size=400, prob=.1, lower.tail = F)
qbinom(.975, size=400, prob=.1, lower.tail = T)
mean(c(52,29))
mean(c(52,29)) / 400
rbinom(1000, size=400, prob=.1)
rbinom(1000, size=400, prob=.1) / 400
rm(list=ls())
N <- 10000
X <- cbind(rep(1, N), rep(5, N))
lin_pred <- X %*% betas
betas <- c(2, .5)
X <- cbind(rep(1, N), rep(5, N))
lin_pred <- X %*% betas
p <- 1. / (1. + exp(- lin_pred))
p
rm(list=ls())
N <- 10000
betas <- c(2, -2)
X <- cbind(rep(1, N), rep(5, N))
lin_pred <- X %*% betas
p <- 1. / (1. + exp(- lin_pred))
p
rm(list=ls())
N <- 10000
betas <- c(5, -1)
X <- cbind(rep(1, N), rep(5, N))
lin_pred <- X %*% betas
p <- 1. / (1. + exp(- lin_pred))
p
y <- rbinom(N, 1, p)
table(y)
glm1 <- glm(y ~ X, family="binomial")
summary(glm1)
glm1 <- glm(y ~ 0 + X, family="binomial")
summary(glm1)
rm(list=ls())
library(TMB)
library(MASS)
setwd("~/Documents/re_simulations/nb_compare/")
N <- 10000
alpha <- .03
betas <- c(2, .5)
M <- length(betas)
nu <- log(rgamma(N, shape=1/alpha, scale=alpha))
X <- cbind(rep(1, N), sapply(2:M, function(x) rnorm(N)))
mu <- exp((X %*% betas) + nu)
y <- rpois(N, mu)
hist(y)
theta <- 1 / alpha # overdispersion parameter
y2 <- rnbinom(N, mu=exp(X %*% betas), size=theta)
hist(y2)
model_name <- "nb2"
if (file.exists(paste0(model_name, ".so"))) file.remove(paste0(model_name, ".so"))
if (file.exists(paste0(model_name, ".o"))) file.remove(paste0(model_name, ".o"))
if (file.exists(paste0(model_name, ".dll"))) file.remove(paste0(model_name, ".dll"))
compile(paste0(model_name, ".cpp"))
dyn.load(dynlib(model_name))
Params <- list(betas=rep(0, M), log_theta=log(1./.7))
Data <- list(X=X, y=y2)
Obj <- MakeADFun(data=Data, parameters=Params, DLL=model_name, silent=T)
Obj$env$tracemgc <- FALSE
Obj$env$inner.control$trace <- FALSE
Obj$env$silent <- TRUE
print("Run time of TMB model for over disperesd poisson...")
Opt <- nlminb(start=Obj$par, objective=Obj$fn, gradient=Obj$gr)
Opt$convergence
Report <- Obj$report()
Report$betas
log(1./.7)
1/.7
Params <- list(betas=rep(0, M), log_theta=log(1./.1))
Data <- list(X=X, y=y2)
Obj <- MakeADFun(data=Data, parameters=Params, DLL=model_name, silent=T)
Obj$env$tracemgc <- FALSE
Obj$env$inner.control$trace <- FALSE
Obj$env$silent <- TRUE
print("Run time of TMB model for over disperesd poisson...")
Opt <- nlminb(start=Obj$par, objective=Obj$fn, gradient=Obj$gr)
Opt$convergence
Report <- Obj$report()
Report$betas
Report$theta
theta
Params <- list(betas=rep(0, M), log_theta=log(theta))
Data <- list(X=X, y=y2)
Obj <- MakeADFun(data=Data, parameters=Params, DLL=model_name, silent=T)
Obj$env$tracemgc <- FALSE
Obj$env$inner.control$trace <- FALSE
Obj$env$silent <- TRUE
print("Run time of TMB model for over disperesd poisson...")
Opt <- nlminb(start=Obj$par, objective=Obj$fn, gradient=Obj$gr)
Opt$convergence
Report <- Obj$report()
Report$betas
Report$theta
rm(list=ls())
library(TMB)
library(MASS)
setwd("~/Documents/re_simulations/nb_compare/")
model_name <- "nb1"
N <- 10000
alpha <- .03
betas <- c(2, .5)
M <- length(betas)
nu <- log(rgamma(N, shape=1/alpha, scale=alpha))
X <- cbind(rep(1, N), sapply(2:M, function(x) rnorm(N)))
mu <- exp((X %*% betas) + nu)
y <- rpois(N, mu)
hist(y)
y2 <- rnbinom(N, mu=exp(X %*% betas), size=theta)
hist(y2)
theta <- 1 / alpha # overdispersion parameter
y2 <- rnbinom(N, mu=exp(X %*% betas), size=theta)
hist(y2)
model_name <- "nb2"
if (file.exists(paste0(model_name, ".so"))) file.remove(paste0(model_name, ".so"))
if (file.exists(paste0(model_name, ".o"))) file.remove(paste0(model_name, ".o"))
if (file.exists(paste0(model_name, ".dll"))) file.remove(paste0(model_name, ".dll"))
compile(paste0(model_name, ".cpp"))
dyn.load(dynlib(model_name))
Params <- list(betas=rep(0, M), log_theta=log(theta))
Data <- list(X=X, y=y2)
Obj <- MakeADFun(data=Data, parameters=Params, DLL=model_name, silent=T)
Obj$env$tracemgc <- FALSE
Obj$env$inner.control$trace <- FALSE
Obj$env$silent <- TRUE
print("Run time of TMB model for over disperesd poisson...")
Opt <- nlminb(start=Obj$par, objective=Obj$fn, gradient=Obj$gr)
Opt$convergence
Report <- Obj$report()
Report$betas
Report$theta
Report$mu
dnbinom(y2, Report$mu, size=Report$theta)
?dnbinom
dnbinom(y2, mu=Report$mu, size=Report$theta)
head(dnbinom(y2, mu=Report$mu, size=Report$theta))
head(dnbinom(y2, mu=Report$mu, size=Report$theta, log=TRUE))
head(dnbinom(y2, mu=Report$mu, size=Report$theta, log=TRUE) * -1)
head(Report$nll_vec_data)
model2 <- glm.nb(y2 ~ X[,2])
summary(model2)
theta
Params <- list(betas=betas, log_theta=log(theta))
Data <- list(X=X, y=y2)
Obj <- MakeADFun(data=Data, parameters=Params, DLL=model_name, silent=T)
Obj$env$tracemgc <- FALSE
Obj$env$inner.control$trace <- FALSE
Obj$env$silent <- TRUE
print("Run time of TMB model for over disperesd poisson...")
Opt <- nlminb(start=Obj$par, objective=Obj$fn, gradient=Obj$gr)
Opt$convergence
Report <- Obj$report()
Report$betas
Report$theta
Params <- list(betas=rep(0, M), log_theta=log(theta))
Data <- list(X=X, y=y2)
Obj <- MakeADFun(data=Data, parameters=Params, DLL=model_name, silent=T)
Obj$env$tracemgc <- FALSE
Obj$env$inner.control$trace <- FALSE
Obj$env$silent <- TRUE
print("Run time of TMB model for over disperesd poisson...")
Opt <- nlminb(start=Obj$par, objective=Obj$fn, gradient=Obj$gr)
Opt$convergence
Params <- list(betas=rep(1, M), log_theta=log(theta))
Data <- list(X=X, y=y2)
Obj <- MakeADFun(data=Data, parameters=Params, DLL=model_name, silent=T)
Obj$env$tracemgc <- FALSE
Obj$env$inner.control$trace <- FALSE
Obj$env$silent <- TRUE
print("Run time of TMB model for over disperesd poisson...")
Opt <- nlminb(start=Obj$par, objective=Obj$fn, gradient=Obj$gr)
Opt$convergence
Params <- list(betas=rep(1, M), log_theta=0)
Data <- list(X=X, y=y2)
Obj <- MakeADFun(data=Data, parameters=Params, DLL=model_name, silent=T)
Obj$env$tracemgc <- FALSE
Obj$env$inner.control$trace <- FALSE
Obj$env$silent <- TRUE
print("Run time of TMB model for over disperesd poisson...")
Opt <- nlminb(start=Obj$par, objective=Obj$fn, gradient=Obj$gr)
Opt$convergence
Params <- list(betas=rep(0, M), log_theta=0)
Data <- list(X=X, y=y2)
Obj <- MakeADFun(data=Data, parameters=Params, DLL=model_name, silent=T)
Obj$env$tracemgc <- FALSE
Obj$env$inner.control$trace <- FALSE
Obj$env$silent <- TRUE
print("Run time of TMB model for over disperesd poisson...")
Opt <- nlminb(start=Obj$par, objective=Obj$fn, gradient=Obj$gr)
Opt$convergence
Report <- Obj$report()
Report$betas
Report$theta
Params <- list(betas=rep(0, M), log_theta=1)
Data <- list(X=X, y=y2)
Obj <- MakeADFun(data=Data, parameters=Params, DLL=model_name, silent=T)
Obj$env$tracemgc <- FALSE
Obj$env$inner.control$trace <- FALSE
Obj$env$silent <- TRUE
print("Run time of TMB model for over disperesd poisson...")
Opt <- nlminb(start=Obj$par, objective=Obj$fn, gradient=Obj$gr)
Opt$convergence
Params <- list(betas=rep(1, M), log_theta=1)
Data <- list(X=X, y=y2)
Obj <- MakeADFun(data=Data, parameters=Params, DLL=model_name, silent=T)
Obj$env$tracemgc <- FALSE
Obj$env$inner.control$trace <- FALSE
Obj$env$silent <- TRUE
print("Run time of TMB model for over disperesd poisson...")
Opt <- nlminb(start=Obj$par, objective=Obj$fn, gradient=Obj$gr)
Opt$convergence
Report <- Obj$report()
Report$betas
Report$theta
rm(list=ls())
library(TMB)
library(MASS)
setwd("~/Documents/re_simulations/nb_compare/")
N <- 10000
alpha <- .03
betas <- c(2, .5)
M <- length(betas)
nu <- log(rgamma(N, shape=1/alpha, scale=alpha))
X <- cbind(rep(1, N), sapply(2:M, function(x) rnorm(N)))
theta <- 1 / alpha # overdispersion parameter
y2 <- rnbinom(N, mu=exp(X %*% betas), size=theta)
hist(y2)
model_name <- "nb2"
if (file.exists(paste0(model_name, ".so"))) file.remove(paste0(model_name, ".so"))
if (file.exists(paste0(model_name, ".o"))) file.remove(paste0(model_name, ".o"))
if (file.exists(paste0(model_name, ".dll"))) file.remove(paste0(model_name, ".dll"))
compile(paste0(model_name, ".cpp"))
dyn.load(dynlib(model_name))
Params <- list(betas=rep(1, M), log_theta=1)
Data <- list(X=X, y=y2)
Obj <- MakeADFun(data=Data, parameters=Params, DLL=model_name, silent=T)
Obj$env$tracemgc <- FALSE
Obj$env$inner.control$trace <- FALSE
Obj$env$silent <- TRUE
print("Run time of TMB model for over disperesd poisson...")
Opt <- nlminb(start=Obj$par, objective=Obj$fn, gradient=Obj$gr)
Opt$convergence
Report <- Obj$report()
Report$betas
Report$theta
Params <- list(betas=rep(1, M), log_theta=log(30))
Data <- list(X=X, y=y2)
Obj <- MakeADFun(data=Data, parameters=Params, DLL=model_name, silent=T)
Obj$env$tracemgc <- FALSE
Obj$env$inner.control$trace <- FALSE
Obj$env$silent <- TRUE
print("Run time of TMB model for over disperesd poisson...")
Opt <- nlminb(start=Obj$par, objective=Obj$fn, gradient=Obj$gr)
Opt$convergence
Report <- Obj$report()
Report$betas
?nlminb
Opt <- nlminb(start=Obj$par, objective=Obj$fn, gradient=Obj$gr,
control=list(iter.max=600, eval.max=800))
Opt$convergence
Params <- list(betas=betas, log_theta=log(theta))
Data <- list(X=X, y=y2)
Obj <- MakeADFun(data=Data, parameters=Params, DLL=model_name, silent=T)
Obj$env$tracemgc <- FALSE
Obj$env$inner.control$trace <- FALSE
Obj$env$silent <- TRUE
print("Run time of TMB model for over disperesd poisson...")
Opt <- nlminb(start=Obj$par, objective=Obj$fn, gradient=Obj$gr,
control=list(iter.max=600, eval.max=800))
Opt$convergence
Report <- Obj$report()
Report$betas
Report$theta
head(dnbinom(y2, mu=Report$mu, size=Report$theta, log=TRUE) * -1)
head(Report$nll_vec_data)
rm(list=ls())
library(TMB)
library(MASS)
setwd("~/Documents/re_simulations/nb_compare/")
N <- 10000
alpha <- .03
betas <- c(2, .5)
M <- length(betas)
nu <- log(rgamma(N, shape=1/alpha, scale=alpha))
X <- cbind(rep(1, N), sapply(2:M, function(x) rnorm(N)))
mu <- exp((X %*% betas) + nu)
y <- rpois(N, mu)
hist(y)
Params <- list(betas=betas, log_theta=log(theta))
theta <- 1 / alpha # overdispersion parameter
y2 <- rnbinom(N, mu=exp(X %*% betas), size=theta)
hist(y2)
model_name <- "nb2"
if (file.exists(paste0(model_name, ".so"))) file.remove(paste0(model_name, ".so"))
if (file.exists(paste0(model_name, ".o"))) file.remove(paste0(model_name, ".o"))
if (file.exists(paste0(model_name, ".dll"))) file.remove(paste0(model_name, ".dll"))
compile(paste0(model_name, ".cpp"))
dyn.load(dynlib(model_name))
Params <- list(betas=rep(1, M), log_theta=log(30))
Params <- list(betas=betas, log_theta=log(theta))
Data <- list(X=X, y=y2)
Obj <- MakeADFun(data=Data, parameters=Params, DLL=model_name, silent=T)
Obj$env$tracemgc <- FALSE
Obj$env$inner.control$trace <- FALSE
Obj$env$silent <- TRUE
print("Run time of TMB model for over disperesd poisson...")
Opt <- nlminb(start=Obj$par, objective=Obj$fn, gradient=Obj$gr,
control=list(iter.max=600, eval.max=800))
Opt$convergence
Report <- Obj$report()
Report$betas
Report$theta
head(dnbinom(y2, mu=Report$mu, size=Report$theta, log=TRUE) * -1)
head(Report$nll_vec_data)
mu[i]
head(exp(X %*% betas))
head(Report$mu)
